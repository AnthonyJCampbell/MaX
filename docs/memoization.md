## Memoization of List Items using React.memo()

We are using memoization in the Max UC Refresher in order to improve the performance of the app. By default, React re-renders any component whose passed-in props have changed, as well as all children in the React render tree.

Within the app in pane B (Midbar), we create a list which then renders list items, each of which contains either contact info, call information, or chat blocks. The encapsulating list retrieves an array of objects (containing contact, call, or chat info), maps over this data and then returns the populated list items. As a result, you've got a single parent (list) with numerous children (list items). The basic flow is as follows:

- A list of objects is stored in the Redux store
- The List component (i.e. parent) retrieves the data and iterates over it
- For every iteration, a new list item then gets declared, with a single object (containing contact, call or chat info) passed in as props to the list item component.
- The resulting list items then get appended to the List component (parent) and rendered.

If a list item gets updated, be it because a contact's presence has changed or for some other reason, it would normally cause _all_ list items to get rerendered. Given that the app is supposed to support a large number of contacts which could lead to many dozens of data mutations per minute, this inefficient render behaviour could very quickly become a performance bottleneck. To combat this inefficiency, we use React.memo() to memoize the props passed into the list item components and reduce the number of re-renders React has to do.

By default, React.memo() executes a comparison of the props passed into the memoized component. It will compel the component to re-render only when it notices that there is a difference between the newly-incoming props and those it was passed the previous render cycle. When props do not change, the component will not re-render, saving precious computing resources. The component (and its children) is then lifted wholesale by React and placed in the newly-re-rendered React render tree.

As a result of this comparison, ints, strings, arrays, and the like can all be passed in directly and React.memo() will recognize when these props change after every render cycle.

React.memo() takes a custom callback, commonly named `areEqual`. which allows us to manually check the existent props (`prevProps`) against the incoming props as part of the new render-cycle (`nextProps`). This function returns either `true` (in which case the values are equal and the component will not rerender) or `false` (in which case the component will re-render).

`prevProps` and `nextProps` are parameters generated by `React.memo()` and then passed on to the callback. However, `React.memo()` executes a shallow comparison between the old and new props before passing the resultant values to `areEqual`. If it finds that the two are equal, it'll normalize `nextProps` to be the same as `prevProps` and pass it on to `areEqual`.

### What To Do

When you want to memoize a component, props should be passed in normally from the parent component to the child component. This can be done in the form of integers, strings, objects, arrays, etc. This makes it accessible through `props` in the child-component as usual.

The child component should then contain the following change:

There are two different ways in including memoization on a component:

1. By adding `React.memo()` to the component instantiation, like so: `const ChildComponent = React.memo(props => <div></div>, areEqual)`
2. By replacing the standard `export default` statement with `export default React.memo(ChildComponent, areEqual);`

In either case, the `areEqual` callback will need to be defined outside the component, not unlike PropTypes). There, we can execute our comparison and return a Boolean value, which controls whether a rerender is executed.

An example of `areEqual` is:

```
const areEqual = (prevProps, nextProps) => {
  return prevProps.object === nextProps.object;
};
```

Finally, this method of memoization and passing in props can be applied to any parent passing props to child components, not just for the list item. Memoization can be useful in a number of different cases where it's expected that there will be a lot of prop changes and rerenders, which could potentially lead to performance hits.

Finally, it should be noted that while React.memo() gives a performance boost from not having to rerender a component in every render cycle, it's not completely free either. During every render cycle, React still has to execute the `areEqual` callback for every single component. Use memoization wisely.

### TL;DR:

- React.memo() compares past props with new props.
- React.memo() executes a callback function to manually check props we desire: `areEqual`.
- `areEqual` is passed two params (`prevProps` and `nextProps`) by React.memo(), representing the two different props.
- `areEqual` then compares the differnt props and returns a Boolean, `false` triggers a rerender, `true` avoids it.

### Extra Resources:

- [React API Reference](https://reactjs.org/docs/react-api.html#reactmemo)
- [Use Memoization Wisely](https://dmitripavlutin.com/use-react-memo-wisely/)
